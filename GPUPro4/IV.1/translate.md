# 实时深度阴影贴图

在离线渲染中，选择深度阴影贴图算法来计算透明物体的阴影，例如头发或烟雾。迄今为止，一些尝试在实时运算中获得相同效果的算法都被受限于使用深度去皮技术来近似解决方案。有因为dx11的引入，从光线使用一个单独渲染pass并不引入任何祭祀的初始算法变得可行。在本章节中，我们讨论如何实现一个用于渲染复杂头发模型的dsm算法，在dx11适配的硬件上实时运行。为了深度阴影贴图的高效过滤，引入一个新颖的查询方案，利用了空间连续性。

## 介绍

如今，实时（软）阴影被常规的用在游戏汇总，修正复杂头发模型的着色和渲染，就像图1.1中展示的那样，留下了一个重要的任务，很难获得可交互甚至实时的帧率。主要问题是，头发具有超级细的结构，头发的复杂可见性，当使用传统阴影贴图的时候，容易产生重构瑕疵。传统阴影贴图保存从光源看去到可见正面的距离，到2d纹理的每个纹素中。这就意味着，只有挡住光线的最近的表面会被补货。第二步，会为每个像素执行一个二值的深度测试，与存储的纹素深度和像素深度做比较，来决定这个像素是否被阴影的。对于不透明物体，它工作良好，但是对于半透明物体，它的缺点是无法正确处理，因为在可见正面之后的每个表面被假设为完全阴影。
半透明物体的阴影是可能的，计算光线透过材质的比率，考虑沿着光线上的所有近的表面的遮挡。对于每个纹素，深度阴影贴图保存了光线透射数量，作为深度的函数（如图1.2所示）。在现实中，这个量化为关联的透射度的深度值的列表，为每个纹素存储。当从相机渲染场景的时候，搜索当前深度值并用来作为一个对透射率函数的查询，接着，相应的剩余的管线被用于正确的对每个像素着色。这篇文章的一个主要部分描述了怎么使用dx11来保存和排序进来的片元，为了重建透射率函数和适当的表现，允许一个快速的透射率查找。
同大多数阴影映射算法一样，深度阴影映射也易于造成锯齿瑕疵。但是，大多数瑕疵可以被自适应技术克服，同样用于传统的阴影贴图，例如PCF。我们会展示DSM如何可以利用相邻像素尖的空间连续性被高效的滤波的。此外，我们扩展这个概念，允许对指数阴影贴图滤波。

## 透射率函数

传统（二值）阴影贴图和深度阴影贴图之间的主要区别在于，对于每个深度阴影贴图测试来说，必须为当前像素的深度估算透射率函数。于是这个函数必须被首先创建和排序。对于光栅化硬件来说，创建是可行的，计算表面不透明度的外透射率。这个想法是，光栅化从光源处观察到的所有几何体，不仅保存第一个深度，而且对于每个纹素保存所有的深度（和关联的不透明度）到一个列表中。按深度对这个列表进行排序之后，给出一个纹素位置，在一个特定的深度的透射率可以被计算，所有深度值小于d的列表项的不透明度
（公式）
这里n(d)是所有在深度值d之前的片元的数量。在阴影查询时，当前片元的深度值，可以被用于查询正确的着色值（例如光线透射的比率），为阴影像素。在下一节，我们将展示如何在dx11硬件上高效的创建和保存这样一个函数。

## 算法

我们的算法可以分割正以下步骤：

* 创建列表项。从光源处渲染场景。所有incomming（in the process of coming in）片元的alpha值和深度值被存到链表中的一个二维结构里。注意，链表的大小只受限于显存，这样允许我们保存不同深度复杂度的透射度函数。
* 处理片元。片元被存储起来，透射度函数是对片元深度值根据个别的alpha值来预计算的，允许一个在传输函数中的快速的查询。最终，透射度方程被简化了。
* 临近链接。对于每个片元，在链表中同样位置的相邻片元也被链接，为了快速找到那些临近片元，他们就深度而言是最接近光源的，并且实现更快的滤波。
* 延迟阴影。对于复杂的头发模型（例如包含很大的深度复杂度和含有很多保存值的透射度函数），DSM的查询会变的很昂贵。于是，延迟着色被使用，先渲染场景一遍，然后在延迟着色中对每个像素只计算着色值一遍。
* 空间滤波。在这个点上，我们利用了临近链接来提供对巨大滤波核的快速查找。DSM思想是为二值阴影贴图合并两个著名的滤波方法。
前三个步骤可以总结为从光源构建DSM结构；后两个步骤为相机的最终着色应用DSM。每个步骤将会在后续段落中更详细的讨论。

### 创建列表项

在现代GPU上实现DSM的最大一个问题是，每个纹素的数据量依赖于场景在纹素位置的深度复杂度，因此可能任意变化。在DX11中，这个问题可以被解决，保存沿着光线方向的每个incoming片元的深度和alpha值到一个纹素级的链表中。总体上，每个链表元素拥有表格1.1中的格式。这里，next表示链表中下一个元素的索引，如果它包含-1，表示当前元素是链表中的最后一个元素。我们也额外保存到前一个元素的链接（使它变成一个双向链表），从相邻像素到片元的，将在后面用到。
我们创建一个两层的结构，高效的将所有片元插入到这些链表中，在灯光空间的单个渲染pass中。链表中的所有片元被存到一个结构中，我们表示为表元素buffer。对于每个像素，我们保存在每个链表中第一个元素的索引到一个分离的buffer中，我们表示为头buffer，因为他指向一个表的第一个元素。如果一个阴影贴图纹素的相应的链表是空的，-1被保存到头buffer中。图1.3展示了一个例子。在这个例子中，从一个单独的链表中的元素1和6（分别的，2和5），和第一个元素1和2倍存到头buffer里。
两个结构（头buffer和表元素buffer）都被存成dx11的(RW)StructuredBuffer，并且被填充，渲染几何体一次，在像素着色器中，使用interlocked操作和buffer counter。InterlockedExchange被用于交换链表头，来保证我们不会面临关于并行的任何问题。buffer counter被用于并行的分配链表元素。一个新的incoming的片元，填充头buffer和表元素buffer的像素着色器，如表1.2所示。

### 处理片元

注意，到现在，列表项没有被排序或者包含最终透射率。这些处理任务是这个步骤的目的。根据深度的所有片元的排序，在一个隔离的cs（对每个像素执行）中完成。我们为每个像素加载一个单独的链表到一个局部数组中，并进行一个局部排序，不需要任何共享内存。因为cs和OpenCL都还不支持递归，快速排序这样的算法并不很适合GPU架构。我们使用插入排序来代替，由于它的简单，并且，众所周知的他在小数组（包含合理的深度复杂度的模型是这种情况）上非常快。我们在实验中确认了这个因素，插入排序产生了两倍的效率，相对于一个快速排序的非递归版本。接着，我们将链表中的alpha值转换成一个透射度函数，依据方程1.1。这意味着，我们为在链表中的每个深度值di预乘透射度，并保存每个片元的透射度，而不是alpha值。注意，这个步骤是用来加速后面的滤波的空间连续性查找。这里，不得不从头部遍历链表，来为每个滤波采样重建透射度，恰恰是我们想避免的。此外，prev链接在算法的本步骤中被保存，以此创建一个双向链表。
为了加速查询时间，我们不得不简化透射率函数。在体积数据的情况中，一个为了处理透射度函数的倾角的复杂的算法被建议用于初始的DSM文章。不过，在头发渲染的情况中，我们使用透射度函数的一个简单的、分段常量的版本。于是，它转变成一个简单但是高效的优化策略，仅仅截断了透射度函数，当它的值不再显著变换的时候，例如（公式）。在我们的实验中，帧率被改进了捷径40%，使用0.001的e值，并没有明显的妥协阴影的质量。注意，一个更复杂的GPU友好的压缩方案被salvi建议，限制透射度函数到一个固定的大小，并对头发和参与介质的阴影都有用。这个方法或者可以用于替代简单的截断，并且，我们相信，它可以和我们的临近链接方法组合起来更好的工作（可能需要进一步的加速查询时间）。

### 临近链接

在这个步骤中，我们将每个链表的每个项（片元）链接到临近链表的项（片元），以光照空间的深度的形式来讲，最接近的。这个步骤的原因是，对于屏幕空间中临近的像素，他们很容易近似的拥有相同的深度，在光照空间中，由于空间连续性。在滤波中，链接启用了在DSM中对一个偏远的深度最近邻直接访问。当我们找到一个对应于光照空间深度的片元时，另一个临近滤波采样的相应的片元可以被快速找到。注意，我们只是创建链表，为大多数的像素，深度值连续性的假设成立的情况。
为了保持总内存尽可能的低，只有左边和上面的临近被存储。这样足够计算所有其他滤波采样，当从一个矩形滤波创空的左下角开始时。为了创建链接，在每个线程（注意，对于每个阴影贴图纹素，有一个线程），我们同事遍历有问题的纹素关联的链表，以及右邻纹素和上邻纹素关联的链表。对于每一个片元，我们遍历每个临近链表，知道我们找到一个深度值更远的片元或者遭遇链表的尾部。然后，最后遍历或者先前遍历的临近片元，是在深度值上与当前片元最接近的一个。我们保存他们的索引，来链接当前片元到他的深度最近邻上，对于每个链表项，我们表示为right和upper。每个链表元素，保存三个额外的整型（两个临近链接和一个前链接）的消耗增加了需要的总内存的25%，但是在滤波中他的回报会变的清楚。


### 延迟阴影

在阴影阶段，我们搜索透射度函数中的深度，他对应于当前像素在观察视角的深度。从前到后遍历在xy平面上的当前坐标对应的链表。查询头buffer来访问链表的头部。透射度函数对应的元素的查找，给出一个正确的透射度值，用来衰减着色。
一个用来稳定帧率和达成实时帧率的点是使用延迟着色管线来绘制阴影。这就意味着，我们在延迟阴影pass中对每个像素做单独的阴影查找之前，首先渲染几何体来存储深度和漫发射着色值到rt中。考虑前向渲染，头发的深度复杂度可能需要对每个像素进行多次昂贵的深度查询（当使用PCF的时候更甚）。

### 空间滤波

对DSM和二值阴影贴图来说，空间抗锯齿都很重要，为了达到高品质的图片。与二值阴影贴图的标准滤波方法（例如使用PCF）相反，我们现在处理每个像素的深度值列表。在我们的情况中，这些深度值不是采样，而是表达了完全的透射度函数，也就意味着，我们不需要在z方向上处理重建或者滤波。因此，我们使用一个经典PCF方程中的2d滤波核，并在屏幕空间中的临近像素之间对比光照空间的深度值。
因为DSM的查询时间非常慢，对于DSM滤波来说有必要避免憨逼的实现，总体查询时间根据滤波大小线性增长。在一个临近像素的完全链表上搜索一个正确的片元简直比登天还昂贵。二分查找会降低复杂度，但是并不是很适用于cs的实现和链表。
替代的，我们利用空间连续性，并且假设深度值最接近的相邻片元在他的链表中拥有同样的索引。在这个阶段我们利用1.3.3中的链式结构，链表元素在深度值上最近，用以为临近片元的查找获得一个好的初始猜测。这种方法，对于每个像素透射度函数必须从开始（头元素）遍历一次，无视使用的滤波大小。当对应当前深度的片元找到了，那么就可能快速访问临近片元，为了计算剩下的滤波采样。
在我么你的视线中，首先计算滤波窗口的左下角对应的片元。然后，被right和upper链接的片元的坐标被使用，作为初始猜测，为了找到DSM中一个临近采样的正确片元位置。接着，顺着着prve或next遍历采样的链表，用以决定正确的深度值（表中的片元位置）。如果空间连续性符合，每个遍历只需要迭代数次。
对于一个7x7大小的滤波核，和真是的透明度设置，这个链接对于一个1280x720的frame-buffer提升了50%的帧率，对于1920x1080分辨率最高可以提升100%，对比对每个滤波核采样进行暴力遍历的方法。注意，这个技术对于头发模型的复杂度缩放良好（越复杂，提速越高），因为只要有足够的连续性，查找时间编程大致的常量。也注意到，这个技术甚至对更大的滤波核缩放良好，因为空间连续性是临近像素之间唯一的要求。在小的透射率函数（例如由于高不透明度）的情况下，链接的提升较小，虽然这只导致了由于这些链表而产生的仅仅显著的常量消耗（大约2%）。
除了PCF，我们还适应了另外一个抗锯齿算法，指数阴影贴图，用于DSM。

指数阴影贴图。标准的二值阴影贴图测试引起了抗锯齿瑕疵，因为他是一个阶梯函数，在0和1之间来回跳跃。于是，指数阴影贴图使用一个指数函数（产生在[0-1]之间连续的结果）来近似阴影测试。这个连续值既而会用于衰减像素的着色。

DSM算法可以和ESM算法用一种直接的方式来组合使用，我们把这个组合表示为指数深度阴影贴图。得到的透射度被连续的阴影测试值加权。看图1.6，EDSM比PCF在视觉质量上表现更加良好。注意，初始的ESM算法支持预滤波，但是这个特性不能用于与DSM的组合上，因为透射度函数的查询深度不是预先知道的。

## 结果
